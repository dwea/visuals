<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Biomarker Sankey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Changed to Inter */
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Ensure container takes full width */
            box-sizing: border-box; /* Include padding in width */
        }

        .title {
            text-align: center;
            color: #2c3e50;
            font-size: 28px;
            font-weight: 300;
            margin-bottom: 30px;
            letter-spacing: 1px;
        }

        .column-header {
            font-size: 14px;
            font-weight: 600;
            color: #34495e;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .link {
            fill: none;
            stroke-opacity: 0; /* Default hidden */
        }
        /* New style for the background links */
        .link-background {
            fill: none;
        }


        .reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 10;
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(231, 76, 60, 0.3);
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            .title {
                font-size: 24px;
                margin-bottom: 20px;
            }
            .reset-btn {
                top: 10px;
                right: 10px;
                padding: 8px 15px;
                font-size: 12px;
            }
            .info-panel {
                bottom: 10px;
                left: 10px;
                padding: 10px;
                font-size: 10px;
                max-width: 200px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>
<body>
    <div class="container">
        <h1 class="title">Biomarker Influence Network</h1>
        <button class="reset-btn" onclick="resetSelection()">Reset</button>

        <svg id="sankey-diagram"></svg>

        <div class="info-panel">
            <strong>Interactive Guide:</strong><br>
            ‚Ä¢ Click on any item to see its relationships<br>
            ‚Ä¢ Link thickness represents strength of influence<br>
            ‚Ä¢ Left flows show metabolic pathways<br>
            ‚Ä¢ Right flows show affected health areas
        </div>
    </div>

    <script>
        // Helper function to generate random percentages for the bars
        function getRandomPercentage(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Data structure
        const data = {
            processes: [
                { id: 'pathway1', name: 'Beta oxidation of fatty acids', icon: 'üîÑ', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway2', name: 'Amino acid metabolism', icon: 'üîÑ', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway3', name: 'Coagulation pathway', icon: 'üîÑ', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway4', name: 'Urea cycle', icon: 'üõ§Ô∏è', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway5', name: 'Glycolysis', icon: 'üõ§Ô∏è', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway6', name: 'Lipid metabolism', icon: 'üõ§Ô∏è', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway7', name: 'Complement cascade', icon: '‚ö°', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway8', name: 'Cascade 2', icon: '‚ö°', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway9', name: 'Cascade 3', icon: '‚ö°', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway10', name: 'Health Area 1', icon: 'üè•', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway11', name: 'Ad Hoc Collection', icon: 'üìä', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) },
                { id: 'pathway12', name: 'Pathway Factors', icon: 'ü©∫', red_value: getRandomPercentage(0, 25), yellow_value: getRandomPercentage(0, 25) }
            ],
            biomarkers: [
                { id: 'bm1', name: 'Tyrosine', value: 75 },
                { id: 'bm2', name: 'Histadine', value: 30 },
                { id: 'bm3', name: 'Asparagine', value: 90 },
                { id: 'bm4', name: 'Pyruvic acid', value: 50 },
                { id: 'bm5', name: 'Threonine', value: 65 },
                { id: 'bm6', name: 'Serine', value: 20 }
            ],
            healthAreas: [
                { id: 'ha1', name: 'Alzheimer‚Äôs Disease', value: getRandomPercentage(55, 100) },
                { id: 'ha2', name: 'Cognitive Health', value: getRandomPercentage(55, 100) },
                { id: 'ha3', name: 'Inflammation', value: getRandomPercentage(55, 100) },
                { id: 'ha4', name: 'Dietary Health', value: getRandomPercentage(55, 100) },
                { id: 'ha5', name: 'Diabetes', value: getRandomPercentage(55, 100) },
                { id: 'ha6', name: 'Cardiovascular Disease', value: getRandomPercentage(55, 100) },
                { id: 'ha7', name: 'Inflammatory Bowel Disease', value: getRandomPercentage(55, 100) },
                { id: 'ha8', name: 'Liver Disease', value: getRandomPercentage(55, 100) }
            ]
        };

        // Relationship mappings with influence strengths
        const relationships = {
            bm1: {
                processes: [
                    { id: 'pathway1', strength: 8 },
                    { id: 'pathway4', strength: 2 },
                    { id: 'pathway7', strength: 7 }
                ],
                healthAreas: [
                    { id: 'ha1', strength: 9 },
                    { id: 'ha2', strength: 5 },
                    { id: 'ha4', strength: 2 }
                ]
            },
            bm2: {
                processes: [
                    { id: 'pathway2', strength: 7 },
                    { id: 'pathway3', strength: 9 },
                    { id: 'pathway8', strength: 2 }
                ],
                healthAreas: [
                    { id: 'ha2', strength: 8 },
                    { id: 'ha3', strength: 6 },
                    { id: 'ha5', strength: 7 }
                ]
            },
            bm3: {
                processes: [
                    { id: 'pathway5', strength: 8 },
                    { id: 'pathway9', strength: 7 },
                    { id: 'pathway12', strength: 4 }
                ],
                healthAreas: [
                    { id: 'ha1', strength: 3 },
                    { id: 'ha6', strength: 8 },
                    { id: 'ha7', strength: 9 }
                ]
            },
            bm4: {
                processes: [
                    { id: 'pathway1', strength: 3 },
                    { id: 'pathway6', strength: 8 },
                    { id: 'pathway11', strength: 6 }
                ],
                healthAreas: [
                    { id: 'ha3', strength: 7 },
                    { id: 'ha4', strength: 8 },
                    { id: 'ha8', strength: 6 }
                ]
            },
            bm5: {
                processes: [
                    { id: 'pathway3', strength: 7 },
                    { id: 'pathway7', strength: 8 },
                    { id: 'pathway10', strength: 6 }
                ],
                healthAreas: [
                    { id: 'ha1', strength: 8 },
                    { id: 'ha5', strength: 9 },
                    { id: 'ha6', strength: 2 }
                ]
            },
            bm6: {
                processes: [
                    { id: 'pathway2', strength: 6 },
                    { id: 'pathway4', strength: 7 },
                    { id: 'pathway9', strength: 8 }
                ],
                healthAreas: [
                    { id: 'ha2', strength: 1 },
                    { id: 'ha7', strength: 8 },
                    { id: 'ha8', strength: 9 }
                ]
            }
        };

        // --- Pre-compute reverse mappings for new interactions ---
        const processToBiomarkers = {};
        const healthAreaToBiomarkers = {};

        for (const bmId in relationships) {
            const bmRelationships = relationships[bmId];
            const biomarker = data.biomarkers.find(b => b.id === bmId);

            // Populate processToBiomarkers
            bmRelationships.processes.forEach(proc => {
                if (!processToBiomarkers[proc.id]) {
                    processToBiomarkers[proc.id] = [];
                }
                processToBiomarkers[proc.id].push({ id: bmId, strength: proc.strength, yCenter: biomarker.yCenter });
            });

            // Populate healthAreaToBiomarkers
            bmRelationships.healthAreas.forEach(ha => {
                if (!healthAreaToBiomarkers[ha.id]) {
                    healthAreaToBiomarkers[ha.id] = [];
                }
                healthAreaToBiomarkers[ha.id].push({ id: bmId, strength: ha.strength, yCenter: biomarker.yCenter });
            });
        }

        // --- Configuration Object ---
        const config = {
            svg: { width: 1340, height: 600 },
            column: {
                processX: 100,
                biomarkerX: 500,
                healthX: 900,
                width: 280
            },
            spacing: {
                headerY: 30,
                itemStartY: 60,
                itemHeight: 40, // Unified item height
                itemVerticalSpacing: 45 // Unified vertical spacing
            },
            textOffset: {
                processX: 15, processY: 25, // Adjusted for unified height
                biomarkerX: 15, biomarkerY: 25,
                healthX: 15, healthY: 25 // Adjusted for unified height
            },
            link: {
                minStrokeWidth: 2,
                strengthMultiplier: 1.5,
                controlOffsetMultiplier: 0.5,
                transitionDuration: 500,
                dashArray: '10, 5',
                dashAnimationSpeed: 4000 // Slowed down to 25% of original speed (4x duration)
            },
            colors: {
                // 10% Tint (Default State)
                processGradient_DEFAULT_Start: '#e0f2f7', processGradient_DEFAULT_End: '#d4edf4',
                biomarkerGradient_DEFAULT_Start: '#f9e0e0', biomarkerGradient_DEFAULT_End: '#f6d4d4',
                healthGradient_DEFAULT_Start: '#dff7e8', healthGradient_DEFAULT_End: '#d0efdd',

                // 20% Tint (Hover State)
                processGradient_HOVER_Start: '#c0e6f2', processGradient_HOVER_End: '#b0dae7',
                biomarkerGradient_HOVER_Start: '#f2c7c7', biomarkerGradient_HOVER_End: '#edbaba',
                healthGradient_HOVER_Start: '#bfe7ce', healthGradient_HOVER_End: '#aedec0',

                // 50% Tint (Selected State / Related Highlighted State)
                processGradient_SELECTED_Start: '#6bb9e2', processGradient_SELECTED_End: '#59a5d0',
                biomarkerGradient_SELECTED_Start: '#e0857d', biomarkerGradient_SELECTED_End: '#d46f67',
                healthGradient_SELECTED_Start: '#6cd19a', healthGradient_SELECTED_End: '#5bc28c',

                // Other colors
                primarySelectedStroke: 'black', // Black stroke for the primary selected item
                processLink: '#3498db',
                healthLink: '#27ae60',
                processToBiomarkerLink: '#3498db',
                healthToBiomarkerLink: '#27ae60',
                headerText: '#2c3e50',
                healthCircleFill: '#2ecc71',
                processBarRed: '#e74c3c',
                processBarYellow: '#f1c40f',
                itemText: 'black'
            }
        };

        const svg = d3.select('#sankey-diagram')
                      .attr('width', config.svg.width)
                      .attr('height', config.svg.height)
                      .attr('viewBox', `0 0 ${config.svg.width} ${config.svg.height}`)
                      .attr('preserveAspectRatio', 'xMidYMid meet');

        // Global state for current selection
        let selectedId = null;
        let selectedType = null;
        // Set to store IDs of currently related/highlighted nodes
        let currentlyRelatedNodeIds = new Set();

        // Helper to define SVG gradients
        function defineGradients(defs) {
            const gradientDefinitions = [
                { id: 'processGradient_DEFAULT', start: config.colors.processGradient_DEFAULT_Start, end: config.colors.processGradient_DEFAULT_End },
                { id: 'biomarkerGradient_DEFAULT', start: config.colors.biomarkerGradient_DEFAULT_Start, end: config.colors.biomarkerGradient_DEFAULT_End },
                { id: 'healthGradient_DEFAULT', start: config.colors.healthGradient_DEFAULT_Start, end: config.colors.healthGradient_DEFAULT_End },

                { id: 'processGradient_HOVER', start: config.colors.processGradient_HOVER_Start, end: config.colors.processGradient_HOVER_End },
                { id: 'biomarkerGradient_HOVER', start: config.colors.biomarkerGradient_HOVER_Start, end: config.colors.biomarkerGradient_HOVER_End },
                { id: 'healthGradient_HOVER', start: config.colors.healthGradient_HOVER_Start, end: config.colors.healthGradient_HOVER_End },

                { id: 'processGradient_SELECTED', start: config.colors.processGradient_SELECTED_Start, end: config.colors.processGradient_SELECTED_End },
                { id: 'biomarkerGradient_SELECTED', start: config.colors.biomarkerGradient_SELECTED_Start, end: config.colors.biomarkerGradient_SELECTED_End },
                { id: 'healthGradient_SELECTED', start: config.colors.healthGradient_SELECTED_Start, end: config.colors.healthGradient_SELECTED_End }
            ];

            gradientDefinitions.forEach(g => {
                const gradient = defs.append('linearGradient').attr('id', g.id);
                gradient.append('stop').attr('offset', '0%').attr('stop-color', g.start);
                gradient.append('stop').attr('offset', '100%').attr('stop-color', g.end);
            });
        }

        // Reusable Biomarker Graph Component
        function biomarkerMiniGraph() {
            let valueAccessor = d => d.value;

            function chart(selection) {
                selection.each(function(d) {
                    const container = d3.select(this);
                    const value = valueAccessor(d);

                    container.selectAll('*').remove();

                    const graphWidth = 60;
                    const labelWidth = 30;
                    const totalGraphAreaWidth = graphWidth + 5 + labelWidth;
                    const graphHeight = 8;
                    const padding = 2;
                    const fillPercentage = value / 100;

                    container.append('rect')
                        .attr('x', padding)
                        .attr('y', padding)
                        .attr('width', graphWidth)
                        .attr('height', graphHeight)
                        .attr('rx', 2)
                        .attr('ry', 2)
                        .attr('fill', 'rgba(0,0,0,0.1)');

                    container.append('rect')
                        .attr('x', padding)
                        .attr('y', padding)
                        .attr('width', graphWidth * fillPercentage)
                        .attr('height', graphHeight)
                        .attr('rx', 2)
                        .attr('ry', 2)
                        .attr('fill', config.colors.itemText);

                    container.append('text')
                        .attr('x', graphWidth + padding + 5)
                        .attr('y', graphHeight / 2 + padding)
                        .attr('dy', '0.35em')
                        .style('font-size', '9px')
                        .style('fill', config.colors.itemText)
                        .text(`${value}%`);
                });
            }

            chart.value = function(accessor) {
                if (!arguments.length) return valueAccessor;
                valueAccessor = accessor;
                return chart;
            };

            return chart;
        }

        // Reusable Health Area Circle Graph Component
        function healthAreaCircleGraph() {
            let valueAccessor = d => d.value;

            function chart(selection) {
                selection.each(function(d) {
                    const container = d3.select(this);
                    const value = valueAccessor(d);

                    container.selectAll('*').remove();

                    const circleRadius = 15;
                    const circleDiameter = circleRadius * 2;
                    const padding = 2;

                    container.append('circle')
                        .attr('cx', circleRadius + padding)
                        .attr('cy', circleRadius + padding)
                        .attr('r', circleRadius)
                        .attr('fill', config.colors.healthCircleFill)
                        .style('stroke', 'white')
                        .style('stroke-width', 1.5);

                    container.append('text')
                        .attr('x', circleRadius + padding)
                        .attr('y', circleRadius + padding)
                        .attr('dy', '0.35em')
                        .style('text-anchor', 'middle')
                        .style('fill', 'white')
                        .style('font-size', '12px')
                        .style('font-weight', 'bold')
                        .text(value);
                });
            }

            chart.value = function(accessor) {
                if (!arguments.length) return valueAccessor;
                valueAccessor = accessor;
                return chart;
            };

            return chart;
        }

        // Reusable Process Multi-Color Bar Graph Component
        function processMultiBarGraph() {
            let redValueAccessor = d => d.red_value;
            let yellowValueAccessor = d => d.yellow_value;

            function chart(selection) {
                selection.each(function(d) {
                    const container = d3.select(this);
                    const redValue = redValueAccessor(d);
                    const yellowValue = yellowValueAccessor(d);

                    container.selectAll('*').remove();

                    const graphWidth = 60;
                    const graphHeight = 8;
                    const padding = 2;

                    container.append('rect')
                        .attr('x', padding)
                        .attr('y', padding)
                        .attr('width', graphWidth)
                        .attr('height', graphHeight)
                        .attr('rx', 2)
                        .attr('ry', 2)
                        .attr('fill', 'rgba(0,0,0,0.1)');

                    const redBarWidth = (redValue / 100) * graphWidth;
                    container.append('rect')
                        .attr('x', padding)
                        .attr('y', padding)
                        .attr('width', redBarWidth)
                        .attr('height', graphHeight)
                        .attr('rx', 2)
                        .attr('ry', 2)
                        .attr('fill', config.colors.processBarRed);

                    const yellowBarWidth = (yellowValue / 100) * graphWidth;
                    container.append('rect')
                        .attr('x', padding + redBarWidth)
                        .attr('y', padding)
                        .attr('width', yellowBarWidth)
                        .attr('height', graphHeight)
                        .attr('rx', 2)
                        .attr('ry', 2)
                        .attr('fill', config.colors.processBarYellow);
                });
            }

            chart.redValue = function(accessor) {
                if (!arguments.length) return redValueAccessor;
                redValueAccessor = accessor;
                return chart;
            };

            chart.yellowValue = function(accessor) {
                if (!arguments.length) return yellowValueAccessor;
                yellowValueAccessor = accessor;
                return chart;
            };

            return chart;
        }

        // Helper to get the correct gradient ID based on type and state
        function getGradientId(type, state) {
            return `${type}Gradient_${state.toUpperCase()}`;
        }

        // Helper to create a column of items
        function createColumn(group, itemsData, type, xPos, startY, itemHeight, verticalSpacing, width, textFormatter, clickHandler = null) {
            const itemGroups = group.selectAll(`.${type}-item-group`)
                .data(itemsData)
                .enter()
                .append('g')
                .attr('class', `${type}-item-group`)
                .style('cursor', 'pointer');

            // Add hover effects
            itemGroups
                .on('mouseover', function(event, d) {
                    // Apply hover if NOT the primary selected item AND NOT a related highlighted item
                    if ((selectedId !== d.id || selectedType !== type) && !currentlyRelatedNodeIds.has(d.id)) {
                        d3.select(this).select(`.${type}-rect`)
                            .transition()
                            .duration(150)
                            .style('fill', `url(#${getGradientId(type, 'hover')})`);
                    }
                })
                .on('mouseout', function(event, d) {
                    // Only revert if NOT the primary selected item AND NOT a related highlighted item
                    if ((selectedId !== d.id || selectedType !== type) && !currentlyRelatedNodeIds.has(d.id)) {
                        d3.select(this).select(`.${type}-rect`)
                            .transition()
                            .duration(150)
                            .style('fill', `url(#${getGradientId(type, 'default')})`);
                    }
                });

            if (clickHandler) {
                itemGroups.on('click', clickHandler);
            }

            itemGroups.append('rect')
                .attr('class', `${type}-rect`)
                .attr('x', xPos)
                .attr('y', (d, i) => startY + i * verticalSpacing)
                .attr('width', width)
                .attr('height', itemHeight)
                .attr('rx', 8)
                .style('fill', `url(#${getGradientId(type, 'default')})`)
                .style('stroke', type === 'biomarker' ? config.colors.biomarkerGradient_DEFAULT_End : 'none') // Biomarker default border
                .style('stroke-width', type === 'biomarker' ? 2 : 0)
                .style('transition', 'all 0.3s ease');

            itemGroups.append('text')
                .attr('x', xPos + config.textOffset[type + 'X'])
                .attr('y', (d, i) => startY + i * verticalSpacing + config.textOffset[type + 'Y'])
                .style('fill', config.colors.itemText)
                .style('font-size', '13px')
                .style('font-weight', '500')
                .text(textFormatter);

            // Integrate mini-graph based on column type
            if (type === 'biomarker') {
                const graphComponent = biomarkerMiniGraph();
                const graphWidth = 60;
                const labelWidth = 30;
                const totalGraphAreaWidth = graphWidth + 5 + labelWidth;
                const graphPadding = 2;

                itemGroups.append('g')
                    .attr('transform', (d, i) => {
                        const graphOffsetX = xPos + width - totalGraphAreaWidth - graphPadding - 10;
                        const graphOffsetY = startY + i * verticalSpacing + (itemHeight - (8 + graphPadding * 2)) / 2;
                        return `translate(${graphOffsetX}, ${graphOffsetY})`;
                    })
                    .call(graphComponent);
            } else if (type === 'health') {
                const graphComponent = healthAreaCircleGraph();
                const circleRadius = 15;
                const graphPadding = 2;
                const totalCircleAreaWidth = (circleRadius * 2) + (graphPadding * 2);

                itemGroups.append('g')
                    .attr('transform', (d, i) => {
                        const graphOffsetX = xPos + width - totalCircleAreaWidth - 10;
                        const graphOffsetY = startY + i * verticalSpacing + (itemHeight - totalCircleAreaWidth) / 2;

                        return `translate(${graphOffsetX}, ${graphOffsetY})`;
                    })
                    .call(graphComponent);
            } else if (type === 'process') {
                const graphComponent = processMultiBarGraph();
                const graphWidth = 60;
                const graphHeight = 8;
                const graphPadding = 2;

                itemGroups.append('g')
                    .attr('transform', (d, i) => {
                        const graphOffsetX = xPos + width - graphWidth - (2 * graphPadding) - 10;
                        const graphOffsetY = startY + i * verticalSpacing + (itemHeight - (graphHeight + (2 * graphPadding))) / 2;

                        return `translate(${graphOffsetX}, ${graphOffsetY})`;
                    })
                    .call(graphComponent);
            }

            // Store yCenter for link drawing
            itemsData.forEach((d, i) => d.yCenter = startY + i * verticalSpacing + itemHeight / 2);
        }

        // Function to highlight a specific node (FIXED: controls stroke more precisely)
        function highlightNode(selector, id, highlight, type) {
            svg.selectAll(selector)
                .filter(d => d.id === id)
                .select(`.${type}-rect`)
                .transition()
                .duration(150)
                // Stroke logic: Primary selected gets black, related highlighted get their column's SELECTED_End color, others none/default
                .style('stroke', (highlight && id === selectedId) ? config.colors.primarySelectedStroke :
                                  (highlight ? config.colors[`${type}Gradient_SELECTED_End`] :
                                               (type === 'biomarker' ? config.colors.biomarkerGradient_DEFAULT_End : 'none')))
                .style('stroke-width', (highlight && id === selectedId) ? 3 :
                                       (highlight ? 2 : (type === 'biomarker' ? 2 : 0))) // 3px for primary, 2px for related highlights
                // Apply selected fill if highlighted (primary or related), default if unhighlighted
                .style('fill', `url(#${getGradientId(type, highlight ? 'selected' : 'default')})`);
        }

        // Main initialization function
        function initializeVisualization() {
            svg.selectAll('*').remove();
            const defs = svg.append('defs');
            defineGradients(defs);

            const linkGroup = svg.append('g').attr('class', 'links');
            const processGroup = svg.append('g').attr('class', 'processes');
            const biomarkerGroup = svg.append('g').attr('class', 'biomarkers');
            const healthGroup = svg.append('g').attr('class', 'health-areas');

            // Column headers
            svg.append('text').attr('x', config.column.processX + config.column.width / 2).attr('y', config.spacing.headerY).attr('class', 'column-header').style('text-anchor', 'middle').style('font-size', '16px').style('fill', config.colors.headerText).text('Metabolic Processes');
            svg.append('text').attr('x', config.column.biomarkerX + config.column.width / 2).attr('y', config.spacing.headerY).attr('class', 'column-header').style('text-anchor', 'middle').style('font-size', '16px').style('fill', config.colors.headerText).text('Biomarkers');
            svg.append('text').attr('x', config.column.healthX + config.column.width / 2).attr('y', config.spacing.headerY).attr('class', 'column-header').style('text-anchor', 'middle').style('font-size', '16px').style('fill', config.colors.headerText).text('Health Areas');

            // Create columns with the new centralized click handler and default fill logic
            createColumn(processGroup, data.processes, 'process', config.column.processX, config.spacing.itemStartY, config.spacing.itemHeight, config.spacing.itemVerticalSpacing, config.column.width, d => `${d.name}`, function(event, d) { handleColumnClick(d.id, 'process'); });
            createColumn(biomarkerGroup, data.biomarkers, 'biomarker', config.column.biomarkerX, config.spacing.itemStartY, config.spacing.itemHeight, config.spacing.itemVerticalSpacing, config.column.width, d => `${d.name}`, function(event, d) { handleColumnClick(d.id, 'biomarker'); });
            createColumn(healthGroup, data.healthAreas, 'health', config.column.healthX, config.spacing.itemStartY, config.spacing.itemHeight, config.spacing.itemVerticalSpacing, config.column.width, d => d.name, function(event, d) { handleColumnClick(d.id, 'health'); });
        }

        // Centralized click handler for all columns
        function handleColumnClick(id, type) {
            // Clear all current related node highlights
            currentlyRelatedNodeIds.clear();

            // Reset all item boxes to their default (10% tint) state and remove all highlight strokes.
            // This ensures a clean slate before applying new selections.
            ['process', 'biomarker', 'health'].forEach(columnType => {
                svg.selectAll(`.${columnType}-item-group`)
                   .select(`.${columnType}-rect`)
                   .transition()
                   .duration(150)
                   .style('fill', `url(#${getGradientId(columnType, 'default')})`)
                   .style('stroke', columnType === 'biomarker' ? config.colors.biomarkerGradient_DEFAULT_End : 'none')
                   .style('stroke-width', columnType === 'biomarker' ? 2 : 0);
            });

            // Always clear all links (both animated and background solid ones)
            svg.select('.links').selectAll('.link, .link-background').interrupt().transition().duration(config.link.transitionDuration / 2).style('stroke-opacity', 0).remove();


            // Determine if the clicked item is already selected
            const isCurrentlySelected = (selectedId === id && selectedType === type);

            // Toggle selection state
            if (isCurrentlySelected) {
                // If the same item is clicked again, unselect it
                selectedId = null;
                selectedType = null;
            } else {
                // Select the new item
                selectedId = id;
                selectedType = type;

                // Apply selected styles to the newly selected primary item's rect
                svg.selectAll(`.${type}-item-group`)
                   .filter(d => d.id === selectedId)
                   .select(`.${type}-rect`)
                   .transition()
                   .duration(150)
                   .style('fill', `url(#${getGradientId(type, 'selected')})`)
                   .style('stroke', config.colors.primarySelectedStroke) // Apply BLACK stroke to primary selected rect
                   .style('stroke-width', 3);

                // Draw links and highlight related nodes for the newly selected item
                // Also populate currentlyRelatedNodeIds
                if (type === 'biomarker') {
                    const bmRelationships = relationships[id];
                    if (bmRelationships && bmRelationships.processes) {
                        bmRelationships.processes.forEach(proc => {
                            currentlyRelatedNodeIds.add(proc.id); // Add to set
                            highlightNode('.process-item-group', proc.id, true, 'process');
                            const processNode = data.processes.find(p => p.id === proc.id);
                            if (processNode) {
                                drawSigmoidLink(config.column.biomarkerX, data.biomarkers.find(b => b.id === id).yCenter, config.column.processX + config.column.width, processNode.yCenter, proc.strength, config.colors.processLink, 'link-bm-to-proc');
                            }
                        });
                    }
                    if (bmRelationships && bmRelationships.healthAreas) {
                        bmRelationships.healthAreas.forEach(health => {
                            currentlyRelatedNodeIds.add(health.id); // Add to set
                            highlightNode('.health-item-group', health.id, true, 'health');
                            const healthNode = data.healthAreas.find(h => h.id === health.id);
                            if (healthNode) {
                                drawSigmoidLink(config.column.biomarkerX + config.column.width, data.biomarkers.find(b => b.id === id).yCenter, config.column.healthX, healthNode.yCenter, health.strength, config.colors.healthLink, 'link-bm-to-ha');
                            }
                        });
                    }
                } else if (type === 'process') {
                    if (processToBiomarkers[id]) {
                        processToBiomarkers[id].forEach(bm => {
                            currentlyRelatedNodeIds.add(bm.id); // Add to set
                            highlightNode('.biomarker-item-group', bm.id, true, 'biomarker');
                            const biomarkerNode = data.biomarkers.find(b => b.id === bm.id);
                            if (biomarkerNode) {
                                drawSigmoidLink(config.column.processX + config.column.width, data.processes.find(p => p.id === id).yCenter, config.column.biomarkerX, biomarkerNode.yCenter, bm.strength, config.colors.processToBiomarkerLink, 'link-proc-to-bm');
                            }
                        });
                    }
                } else if (type === 'health') {
                    if (healthAreaToBiomarkers[id]) {
                        healthAreaToBiomarkers[id].forEach(bm => {
                            currentlyRelatedNodeIds.add(bm.id); // Add to set
                            highlightNode('.biomarker-item-group', bm.id, true, 'biomarker');
                            const biomarkerNode = data.biomarkers.find(b => b.id === bm.id);
                            if (biomarkerNode) {
                                drawSigmoidLink(config.column.healthX, data.healthAreas.find(h => h.id === id).yCenter, config.column.biomarkerX + config.column.width, biomarkerNode.yCenter, bm.strength, config.colors.healthToBiomarkerLink, 'link-ha-to-bm');
                            }
                        });
                    }
                }
            }
        }

        // The drawSigmoidLink function (FIXED: Added background solid line)
        function drawSigmoidLink(x1, y1, x2, y2, strength, color, className) {
            const strokeWidth = Math.max(config.link.minStrokeWidth, strength * config.link.strengthMultiplier);
            const dx = x2 - x1;
            const controlOffset = Math.abs(dx) * config.link.controlOffsetMultiplier;

            let cp1x, cp2x;
            if (x2 > x1) {
                cp1x = x1 + controlOffset;
                cp2x = x2 - controlOffset;
            } else {
                cp1x = x1 - controlOffset;
                cp2x = x2 + controlOffset;
            }

            const pathData = `M ${x1},${y1} C ${cp1x},${y1} ${cp2x},${y2} ${x2},${y2}`;

            const linkGroup = svg.select('.links');

            // NEW: Background solid line
            linkGroup.append('path')
                .attr('class', `link-background ${className}-background`) // Add a distinct class
                .attr('d', pathData)
                .style('stroke', color)
                .style('stroke-width', strokeWidth) // <-- Same width as main line
                .style('stroke-opacity', 0.5) // 50% opacity
                .style('fill', 'none')
                .style('stroke-dasharray', 'none'); // Solid line

            // Main animated dashed line
            const path = linkGroup.append('path')
                .attr('class', `link ${className}`)
                .attr('d', pathData)
                .style('stroke', color)
                .style('stroke-width', strokeWidth) // <-- Same width as main line
                .style('stroke-dasharray', config.link.dashArray)
                .style('stroke-opacity', 0) // Start hidden, then animate in
                .style('fill', 'none');

            const dashPatternLength = path.node().getTotalLength();
            let initialOffset, targetOffset;

            if (className === 'link-ha-to-bm' || className === 'link-bm-to-proc') {
                initialOffset = dashPatternLength;
                targetOffset = 0;
            } else {
                initialOffset = 0;
                targetOffset = -dashPatternLength;
            }

            path.attr('stroke-dashoffset', initialOffset);

            function animateDash() {
                path.transition()
                    .duration(config.link.dashAnimationSpeed)
                    .ease(d3.easeLinear)
                    .attr('stroke-dashoffset', targetOffset)
                    .on('end', () => {
                        path.attr('stroke-dashoffset', initialOffset);
                        animateDash();
                    });
            }

            path.transition()
                .duration(config.link.transitionDuration)
                .style('stroke-opacity', 0.7)
                .on('end', animateDash);
        }

        // Reset highlights and links only (FIXED: targets both link classes)
        function resetHighlightsAndLinks() {
            // Remove all links (both animated and background solid ones)
            svg.select('.links').selectAll('.link, .link-background').interrupt().transition().duration(config.link.transitionDuration / 2).style('stroke-opacity', 0).remove();
        }

        // Public reset function (for the button)
        function resetSelection() {
            // Clear related nodes set
            currentlyRelatedNodeIds.clear();
            selectedId = null;
            selectedType = null;

            // Reset all item boxes to their default (10% tint) state and remove all highlight strokes.
            ['process', 'biomarker', 'health'].forEach(columnType => {
                svg.selectAll(`.${columnType}-item-group`)
                   .select(`.${columnType}-rect`)
                   .transition()
                   .duration(150)
                   .style('fill', `url(#${getGradientId(columnType, 'default')})`)
                   .style('stroke', columnType === 'biomarker' ? config.colors.biomarkerGradient_DEFAULT_End : 'none')
                   .style('stroke-width', columnType === 'biomarker' ? 2 : 0);
            });

            // Clear all links (both animated and background solid ones)
            svg.select('.links').selectAll('.link, .link-background').interrupt().transition().duration(config.link.transitionDuration / 2).style('stroke-opacity', 0).remove();
        }

        // Initialize the visualization on page load
        initializeVisualization();
    </script>
</body>
</html>